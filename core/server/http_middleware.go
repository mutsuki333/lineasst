/*
	middleware.go
	Purpose: Middleware such as logging, panic recovery, etc. for gin or grpc.

	@author Evan Chen
*/

package server

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"app/core/errors"
	"app/core/msg"
	"app/core/property"

	"golang.org/x/exp/slog"
	"google.golang.org/grpc/codes"
	"google.golang.org/protobuf/encoding/protojson"
)

// ProxyWriter is a wrapper of http.ResponseWriter, its main pourpose is to identify
// whether the proxy gateway has generate it's own errors
// that might not be catch by the unaryInterceptor.
type ProxyWriter struct {
	// Writer is the original http.ResponseWriter
	Writer http.ResponseWriter
	status int
	err    *errors.Error
}

// rpc_status is a structure to reflect google.golang.org/genproto/googleapis/rpc/status.Status.
// In order to unmarshal from byte[].
//
//   - https://github.com/googleapis/go-genproto/blob/main/googleapis/rpc/status/status.pb.go
//   - https://pkg.go.dev/google.golang.org/genproto/googleapis/rpc/status
type rpc_status struct {
	Code    int32  `json:"code,omitempty"`
	Message string `json:"message,omitempty"`
	Details []*struct {
		TypeUrl string `json:"@type,omitempty"`
	} `json:"details,omitempty"`
}

// Header is a wrapper to http.ResponseWriter.Header().
//
// It returns the header map that will be sent by WriteHeader.
// The Header map also is the mechanism with which Handlers can set HTTP trailers.
func (w *ProxyWriter) Header() http.Header {
	return w.Writer.Header()
}

// Write is a wrapper to http.ResponseWriter.Write([]byte).
// It also catches errors that are not generated by the common library,
// and upcasts it to compatible error.
func (w *ProxyWriter) Write(b []byte) (int, error) {
	if w.status >= 400 {
		stat := &rpc_status{}
		json.Unmarshal(b, stat)

		// If an error has no detials
		// or the first detial object is not `type.googleapis.com/error.ErrorDetial`.
		// It is likely generated by other packages other than mesexpress.
		// We will try to upcast it to our own error structure.
		if len(stat.Details) == 0 || stat.Details[0].TypeUrl != "type.googleapis.com/error.ErrorDetial" {
			w.err = errors.New(
				errors.ECodeFromGCode(codes.Code(stat.Code)),
				codes.Code(stat.Code),
				msg.Plain(stat.Message))
			nb, _ := protojson.Marshal(w.err.GRPCStatus().Proto())
			return w.Writer.Write(nb)
		}

	}
	return w.Writer.Write(b)
}

// WriteHeader is a wrapper to http.ResponseWriter.WriteHeader(int).
//
// It sends an HTTP response header with the provided status code.
func (w *ProxyWriter) WriteHeader(i int) {
	w.status = i
	w.Writer.WriteHeader(i)
}

func (w *ProxyWriter) Err() *errors.Error {
	return w.err
}

// allowCORS allows Cross Origin Resoruce Sharing from any origin.
// Don't do this without consideration in production systems.
func allowCORS(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if origin := r.Header.Get("Origin"); origin != "" {
			w.Header().Set("Access-Control-Allow-Origin", origin)
			if r.Method == "OPTIONS" && r.Header.Get("Access-Control-Request-Method") != "" {
				preflightHandler(w, r)
				return
			}
		}
		h.ServeHTTP(w, r)
	})
}

// preflightHandler adds the necessary headers in order to serve
// CORS from any origin using the methods "GET", "HEAD", "POST", "PUT", "DELETE"
// We insist, don't do this without consideration in production systems.
func preflightHandler(w http.ResponseWriter, r *http.Request) {
	headers := []string{"Content-Type", "Accept", "Authorization"}
	w.Header().Set("Access-Control-Allow-Headers", strings.Join(headers, ","))
	methods := []string{"GET", "HEAD", "POST", "PUT", "DELETE"}
	w.Header().Set("Access-Control-Allow-Methods", strings.Join(methods, ","))
}

func gatewayInterceptor(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		new_rw := &ProxyWriter{Writer: w}

		switch property.APP_STATE {
		case property.STATE_LOAD, property.STATE_TERM:
			new_rw.WriteHeader(http.StatusServiceUnavailable)
			new_rw.Write([]byte(errors.ErrServiceUnavailable.String()))
		default:
			h.ServeHTTP(new_rw, r)
		}

		// As all successful grpc calls will be logged at the grpc unaryInterceptor,
		// we only catch and log errors that is thrown if the call never reached grpc server.
		if new_rw.Err() != nil {
			rpc := ""
			args := []any{
				slog.String("method", grpc_method),
				slog.String("ip", r.RemoteAddr),
				slog.Duration("duration", time.Since(start)),
				slog.String("rpc", rpc),
			}

			args = append(args,
				slog.Int("status", int(new_rw.err.Status)),
				slog.String("code", new_rw.err.Code),
				new_rw.err.Attr(),
			)
			log.Error(fmt.Sprintf("%s %s", grpc_method, rpc), args...)
		}
	})
}
